From c69aa388499804793facb492e5ce69f547d722cb Mon Sep 17 00:00:00 2001
From: CTCaer <ctcaer@gmail.com>
Date: Fri, 2 Oct 2020 19:38:36 +0100
Subject: [PATCH] Support suspend wakeup on icosa

Icosa has HW issues that prevent it from waking up from D3 with ASPM,
so we instead manually reset it after every wakeup.

Reset function based upon '4684997d9eea'
---
 backports-wireless/defconfigs/brcmfmac        |  2 +-
 .../broadcom/brcm80211/brcmfmac/common.h      |  1 +
 .../brcm80211/brcmfmac/nv/nv_common.c         |  2 +
 .../broadcom/brcm80211/brcmfmac/pcie.c        | 79 +++++++++++++++++++
 4 files changed, 83 insertions(+), 1 deletion(-)

diff --git a/backports-wireless/defconfigs/brcmfmac b/backports-wireless/defconfigs/brcmfmac
index cce4cbe..ad75524 100644
--- a/backports-wireless/defconfigs/brcmfmac
+++ b/backports-wireless/defconfigs/brcmfmac
@@ -22,4 +22,4 @@ CPTCFG_BRCMFMAC_SDIO=n
 CPTCFG_BRCMFMAC_USB=n
 CPTCFG_BRCMFMAC_PCIE=y
 CPTCFG_BRCMFMAC_ANDROID=y
-CPTCFG_BRCM_INSMOD_NO_FW=y
+# CPTCFG_BRCM_INSMOD_NO_FW is not set
diff --git a/backports-wireless/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h b/backports-wireless/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
index 1f2d19c..476c22f 100644
--- a/backports-wireless/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
+++ b/backports-wireless/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
@@ -44,6 +44,7 @@ struct brcmf_mp_global_t {
 	uint	intr_flags;
 	int	wlan_pwr;
 	int	wlan_rst;
+	bool reset_on_wake;
 #endif /* CPTCFG_BRCMFMAC_NV_GPIO */
 #ifdef CPTCFG_BRCMFMAC_NV_COUNTRY_CODE
 	int	n_country;
diff --git a/backports-wireless/drivers/net/wireless/broadcom/brcm80211/brcmfmac/nv/nv_common.c b/backports-wireless/drivers/net/wireless/broadcom/brcm80211/brcmfmac/nv/nv_common.c
index 051b2ad..1165e2d 100644
--- a/backports-wireless/drivers/net/wireless/broadcom/brcm80211/brcmfmac/nv/nv_common.c
+++ b/backports-wireless/drivers/net/wireless/broadcom/brcm80211/brcmfmac/nv/nv_common.c
@@ -98,6 +98,8 @@ void tegra_setup_gpio(struct platform_device *pdev, bool on)
 #ifdef CPTCFG_BRCMFMAC_NV_PRIV_CMD
 	builtin_roam_disabled = device_property_read_bool(&pdev->dev, "builtin-roam-disabled");
 #endif /* CPTCFG_BRCMFMAC_NV_PRIV_CMD */
+
+	brcmf_mp_global.reset_on_wake = of_property_read_bool(node, "reset-on-wake");
 }
 
 int tegra_toggle_gpio(bool on, unsigned long msec)
diff --git a/backports-wireless/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c b/backports-wireless/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
index 0b1e613..20a0ec8 100644
--- a/backports-wireless/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+++ b/backports-wireless/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
@@ -271,6 +271,8 @@ struct brcmf_pciedev_info {
 	void (*write_ptr)(struct brcmf_pciedev_info *devinfo, u32 mem_offset,
 			  u16 value);
 	struct brcmf_mp_device *settings;
+	struct work_struct bus_reset;
+	bool bus_in_reset;
 };
 
 struct brcmf_pcie_ringbuf {
@@ -329,6 +331,10 @@ static const u32 brcmf_ring_itemsize[BRCMF_NROF_COMMON_MSGRINGS] = {
 	BRCMF_D2H_MSGRING_RX_COMPLETE_ITEMSIZE
 };
 
+static void brcmf_pcie_setup(struct device *dev, int ret,
+			     const struct firmware *fw,
+			     void *nvram, u32 nvram_len);
+
 
 static u32
 brcmf_pcie_read_reg32(struct brcmf_pciedev_info *devinfo, u32 reg_offset)
@@ -1392,6 +1398,41 @@ static const struct brcmf_bus_ops brcmf_pcie_bus_ops = {
 	.get_fwname = brcmf_pcie_get_fwname,
 };
 
+static void brcmf_pcie_reset(struct work_struct *work)
+{
+	struct brcmf_pciedev_info *devinfo =
+			container_of(work, struct brcmf_pciedev_info,
+					      bus_reset);
+	struct device *dev = &devinfo->pdev->dev;
+	int err;
+
+	if (devinfo->bus_in_reset) {
+		dev_err(dev, "Already into reset, aborting...\n");
+		return;
+	}
+
+	devinfo->bus_in_reset = true;
+
+	brcmf_pcie_intr_disable(devinfo);
+
+	brcmf_pcie_bus_console_read(devinfo);
+
+	brcmf_detach(dev);
+
+	brcmf_pcie_release_irq(devinfo);
+	brcmf_pcie_release_scratchbuffers(devinfo);
+	brcmf_pcie_release_ringbuffers(devinfo);
+	brcmf_pcie_reset_device(devinfo);
+
+	err = brcmf_fw_get_firmwares_pcie(dev, BRCMF_FW_REQUEST_NVRAM |
+						    BRCMF_FW_REQ_NV_OPTIONAL,
+					  devinfo->fw_name, devinfo->nvram_name,
+					  brcmf_pcie_setup,
+					  pci_domain_nr(devinfo->pdev->bus),
+					  devinfo->pdev->bus->number);
+	if (err)
+		dev_err(dev, "Failed to prepare FW request: %d\n", err);
+}
 
 static void
 brcmf_pcie_adjust_ramsize(struct brcmf_pciedev_info *devinfo, u8 *data,
@@ -1759,6 +1800,7 @@ static void brcmf_pcie_setup(struct device *dev, int ret,
 
 	brcmf_pcie_intr_enable(devinfo);
 	if (brcmf_pcie_attach_bus(devinfo) == 0) {
+		devinfo->bus_in_reset = false;
 #ifdef CPTCFG_BRCM_INSMOD_NO_FW
 		brcmf_wake_dev_reset_waitq(drvr, 0);
 #endif
@@ -1884,6 +1926,9 @@ brcmf_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 						    BRCMF_FW_REQ_NV_OPTIONAL,
 					  devinfo->fw_name, devinfo->nvram_name,
 					  brcmf_pcie_setup, domain_nr, bus_nr);
+
+	INIT_WORK(&devinfo->bus_reset, brcmf_pcie_reset);
+
 	if (ret == 0)
 		return 0;
 fail_bus:
@@ -1965,6 +2010,29 @@ static int brcmf_pcie_pm_enter_D3(struct device *dev)
 	brcmf_android_wake_lock_waive(bus->drvr, true);
 	brcmf_bus_change_state(bus, BRCMF_BUS_DOWN);
 
+	
+	/*
+	 * Some devices hang in D3 randomly or when not connected.
+	 * To mitigate that issue do not inform them that host enters D3.
+	 */
+	if (brcmf_mp_global.reset_on_wake) {
+		/* Check if suspend was asked too soon */
+		if (devinfo->bus_in_reset) {
+			brcmf_err("Device in reset, aborting suspend!\n");
+#ifdef CPTCFG_NV_CUSTOM_SYSFS_TEGRA
+			tegra_sysfs_resume();
+#endif
+			brcmf_android_wake_lock_waive(bus->drvr, false);
+			return -EPERM;
+		}
+
+		brcmf_bus_change_state(bus, BRCMF_BUS_DOWN);
+		brcmf_android_wake_lock_waive(bus->drvr, false);
+
+		return 0;
+	}
+
+
 	devinfo->mbdata_completed = false;
 	brcmf_pcie_send_mb_data(devinfo, BRCMF_H2D_HOST_D3_INFORM);
 
@@ -1999,6 +2067,17 @@ static int brcmf_pcie_pm_leave_D3(struct device *dev)
 	devinfo = bus->bus_priv.pcie->devinfo;
 	brcmf_dbg(PCIE, "Enter, dev=%p, bus=%p\n", dev, bus);
 
+	/* Check if device requires a reset after D3 */
+	if (brcmf_mp_global.reset_on_wake) {
+		brcmf_err("Resetting device after wake up!\n");
+
+#ifdef CPTCFG_NV_CUSTOM_SYSFS_TEGRA
+		tegra_sysfs_resume();
+#endif
+		schedule_work(&devinfo->bus_reset);
+		return 0;
+	}
+
 	/* Check if device is still up and running, if so we are ready */
 	if (brcmf_pcie_read_reg32(devinfo, BRCMF_PCIE_PCIE2REG_INTMASK) != 0) {
 		brcmf_dbg(PCIE, "Try to wakeup device....\n");
-- 
2.28.0

